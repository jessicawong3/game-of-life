/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package gameoflife;

import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.Timer;

/**
 *
 * @author Jessica Wong
 */
public class AnimationPanel extends javax.swing.JPanel {
    
    // variables for a game of life game, timer, grid size at default 20, and cell size at default 10
    GameOfLife game;
    Timer t = new Timer(1000, new TimerListener());
    int gridSize = 20;
    int cellSize = 10;

    /** Creates new form AnimationPanel */
    public AnimationPanel() {
        initComponents();
        // create a new game board
        game = new GameOfLife(gridSize);
    }
    
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        // for each cell in the game grid, draw a rectangle
        for (int i = 0; i < game.grid.length; i++){
            for (int j = 0; j<game.grid[0].length; j++){
                // if the cell is alive, fill the rectangle
                if (game.grid[i][j] == true) {                    
                    g.fillRect(j*cellSize, i*cellSize, cellSize, cellSize);
                // else blank rectangle
                } else {
                    g.drawRect(j*cellSize, i*cellSize, cellSize, cellSize);
                }                
            }
        }
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    private class TimerListener implements ActionListener {

        @Override
        public void actionPerformed(ActionEvent ae) {
            // make the changes for one round
            game.oneRound();
            // repaint the game board
            repaint();
        }
        
    }
    
    /**
     * Starts the timer to show animation
     */
    public void anim() {
        // start the timer
        t.start();
    }
    
    /**
     * Stops the timer, therefore stopping the animation
     */
    public void stopAnim() {
        // stop the timer
        t.stop();
    }
    
    /**
     * Randomizes the game board (random placement and number of dead and alive cells)
     */
    public void randomize() {
        // randomize the position/number of alive and dead cells by looping through each cell
        for (int i = 0; i < game.grid.length; i++){
            for (int j = 0; j<game.grid[0].length; j++){
                // get a random number(between 0 and 1)
                double randomNum = Math.random();
                // cell is live if the random number is greater than 0.7
                // (0.7 gives a greater chance of a dead cell so that the grid isn't too full)
                if (randomNum > 0.7) {
                    game.grid[i][j] = true;
                } else {
                    game.grid[i][j] = false;
                }
            }
        }
        // repaint so that the cells show up regardless of if the program has started or not
        repaint();
    }
    
    /**
     * Resets the game board grid so that there are no living cells
     */
    public void resetGrid() {
        // reset all cells to dead
        for (int i = 0; i < game.grid.length; i++){
            for (int j = 0; j<game.grid[0].length; j++){
                game.grid[i][j] = false;
            }
        }        
        // repaint so that the cells show up regardless of if the program has started or not
        repaint();
    }
    
    /**
     * Changes the living state of a cell when clicked
     * @param mPos The position of the mouse as a point
     */
    public void cellClick(Point mPos) {
        // for all cells
        for (int i = 0; i < game.grid.length; i++){
            for (int j = 0; j<game.grid[0].length; j++){
                // if the mouse position is in the cell
                if (mPos.x > j*cellSize && mPos.x < j*cellSize + cellSize && mPos.y > i*cellSize && mPos.y < i*cellSize + cellSize) {
                    // change to dead cell if already live
                    if (game.grid[i][j] == true) {
                        game.grid[i][j] = false;
                    // change to live cell if already dead
                    } else {
                        game.grid[i][j] = true;
                    }
                }
            }
        }        
        repaint();
    }
    
    /**
     * Changes cell to a preset layout
     */
    public void presetPattern(){
        // clear all the cells
        for (int i = 0; i < game.grid.length; i++){
            for (int j = 0; j<game.grid[0].length; j++){
                game.grid[i][j] = false;
            }
        }
        
        // change specific cells to live
        for (int i = 7; i < 12; i++) {
            for (int j = 7; j < 12; j++) {
                game.grid[i][j] = true;
            }
        }
        
        // remove middle cell
        game.grid[9][9] = false;
        
        repaint();
    }
    
    
}
